CONFIG := memcheck
### some variables and targets are stored in a shared makefile
include Makefile.common
# paths
CHK := $(TST)/check_files
SRC_B := $(BLD)/src
T_INC := $(TST)/headers
# filenames specification
TST_REPORT_R := $(REPORTS)/memcheck_report_raw.log
# project files
T_SRCS := $(SRCS:$(SRC)/s21_%.c=$(SRC_B)/%_test.c)
T_EXES := $(SRCS:$(SRC)/s21_%.c=$(BIN)/%_test)
# compilation parameters
CK_FORK=no# proper way of memory usage checking when using 'check' framework
LDLIBS += $(shell pkg-config --libs-only-l check)
LDFLAGS += $(shell pkg-config --libs-only-L check)
INCFLAGS += -I$(T_INC)
MEM := valgrind
MEMFLAGS := --leak-check=full --show-leak-kinds=all --track-origins=yes -s
DBGFLAGS := -g
export CK_FORK SHELL


.PHONY: memcheck
memcheck: $(T_EXES)
	echo -e "\n\nyou can check saved $(MEMCHECK) logs at $(TST_REPORT_R)"

$(BIN)/%_test: $(SRC)/s21_%.c $(SRC_B)/%_test.c | $(REPORTS)
	$(dir_guard)
	$(CC) $(CFLAGS) $^ $(LDFLAGS) $(LDLIBS) -o $@
ifeq ($(DEBUG), 1)
	-$(MEM) $(MEMFLAGS) $@ > /dev/null 2> /dev/null
else
	-(echo && $(MEM) $(MEMFLAGS) $@) > >(tee -a $(TST_REPORT_R)) 2> >(tee -a $(TST_REPORT_R) | grep -m 2 -e "at exit" -e "ERROR SUMMARY")
endif

$(SRC_B)/%_test.c: $(CHK)/%_test.check
	$(dir_guard)
	checkmk clean_mode=1 $< > $@
	$(format_the_file)

$(REPORTS):
	@$(MK) $@